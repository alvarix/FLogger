This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-22T15:03:12.262Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
components/
  AddEntry.vue
  AddFlog.vue
  DropBoxFiles.vue
  DropBoxFlogs.vue
  Entry.vue
  EntryList.vue
  LocalFileFlogs.vue
  OpenFlogs.vue
composables/
  useDropboxFiles.ts
  useDropboxFlogs.ts
  useFlogs.ts
  useLoadedEntries.ts
  useLocalFileFlogs.ts
modules/
  EntryData.ts
  Flog.ts
App.vue
main.js
style.css

================================================================
Repository Files
================================================================

================
File: components/AddEntry.vue
================
<script setup>
import { ref, watch, onMounted, nextTick  } from 'vue'
import EntryData from '../modules/EntryData.ts';
import { defineEmits } from 'vue';


const props = defineProps({
  copiedEntry: Object // Accept the copied entry as a prop
});


const emit = defineEmits(['newEntry']);
const newEntry = ref('');  // Initialize newEntry as a reactive variable

// as per compiler: [@vue/compiler-sfc] `defineEmits` is a compiler macro and no longer needs to be imported.
let hasError = ref(false);	

let form = ref( 
			new EntryData( 
				new Date().toLocaleDateString(),
				'',
			),
);

const submitAdd = (event) => {
//			 if (this.isValidDate() == true ) {
	//console.log(form)
	 emit('newEntry', form);
//		 } else {
//		 	this.hasError= true;

//		 }

};

// Function to automatically resize the textarea based on content
const autoResizeTextarea = (el_id) => {
  const textarea = document.getElementById(el_id);
  if (textarea) {
    textarea.style.height = 'auto'; // Reset height to shrink if needed
    textarea.style.height = `${textarea.scrollHeight}px`; // Set the height based on scrollHeight
  }
};


watch(() => props.copiedEntry, (newVal) => {
  if (newVal && newVal.entry) {
    form.value.entry = newVal.entry; // Prepopulate the textarea with the copied entry
	const addEntryForm = document.getElementById('add-entry');

	nextTick(() => autoResizeTextarea('entry')); // Adjust the textarea size after the DOM update

    if (addEntryForm) {
      addEntryForm.scrollIntoView({ behavior: 'smooth' }); // Smooth scroll to the form
    }
  }
});
</script>

<template>




	<form  id='add-entry' @submit.prevent="submitAdd">
		<div class="form-inner">
			<div>
				<input :class="['date', {error:hasError}]" id='time' type="text" :placeholder="form.date" v-model="form.date" required >
				
				<em class='date-validation hidden' :class={error:hasError}>Please enter valid date</em>
			</div>
			<div>
				<textarea autofocus id="entry" name="" cols="30" rows="2" v-model='form.entry' required></textarea>
			</div>
		</div>
		<div><input type="submit" value="Add Entry"></div>
		
	</form>
</template>

<style scoped>
#add-entry *:not(.date-validation) {
	display:block;
}

input.error {
	border:1px solid red;
}

input[type='submit'],
.form-inner,
.form-inner * {
	background-color:cornsilk;
}

@media (prefers-color-scheme: dark) {
	input[type='submit'],
	.form-inner,
	.form-inner * {
		background-color:#333;
	}
}

.form-inner {
    max-width: 600px;
    border-radius: 14px;
    padding: 20px;
}
.form-inner,
input[type='submit'] {
	border: 1px solid #ccc;
}

input.date {
	font-weight: bold;
	font-size: 14px;
	border: none;
}

input, textarea {
	padding: 5px;
}

textarea {
	width: 100%;
}

.date-validation.error {
	display:block;
	color:red;
}

input[type=submit] {
	border-radius: 10px;
	padding: 6px 10px;
	margin-top: 10px;
	cursor: pointer;
}

#add-entry label {
	margin-top: 20px;
}

</style>

================
File: components/AddFlog.vue
================
<script setup>
import { ref, watch, onMounted, nextTick } from "vue";
// as per compiler: [@vue/compiler-sfc] `defineEmits` is a compiler macro and no longer needs to be imported.
// import { defineEmits } from "vue";

const emit = defineEmits(["newFlog"]);
const newFlog = ref({ filename: "" }); // Initialize newFlog as a reactive variable

let showInput = ref(false);

let hasError = ref(false);

const submitAdd = () => {
  emit("newFlog", newFlog);
};
</script>

<template>
  <div v-if="!showInput">
    <button
      @click="
        () => {
          showInput = true;
        }
      "
    >
      add new flog
    </button>
  </div>
  <form v-else id="add-flog" @submit.prevent="submitAdd">
    <div class="form-inner">
      <div>
        <input
          :class="['filename', { error: hasError }]"
          id="filename"
          type="text"
          :placeholder="newFlog.filename"
          v-model="newFlog.filename"
          required
        />
        <em class="date-validation hidden" :class="{ error: hasError }"
          >Please enter valid file name</em
        >
      </div>
    </div>
    <div>
      <input type="submit" value="Add Flog" /> 
      <input
        type="button"
        value="Cancel"
        @click="
          () => {
            showInput = false;
          }
        "
      />
    </div>
  </form>
</template>

<style scoped>
input.error {
  border: 1px solid red;
}

input[type="submit"],
input[type="button"] {
  display: inline-block;
  background-color: cornsilk;
  border: 1px solid #ccc;
  border-radius: 10px;
  padding: 6px 10px;
  margin: 10px 7px 0px 0px;
  cursor: pointer;
}

.form-inner,
.form-inner * {
  background-color: cornsilk;
}

.form-inner {
  max-width: 600px;
  border-radius: 14px;
  padding: 20px;
  border: 1px solid #ccc;
}

input.filename {
  font-weight: bold;
  font-size: 14px;
  border: none;
  color: cornflowerblue;
  padding: 5px;
  width: 100%;
}

.date-validation.error {
  display: block;
  color: red;
}

#add-flog label {
  margin-top: 20px;
}
</style>

================
File: components/DropBoxFiles.vue
================
<script setup>
import { ref } from "vue";
import fetch from "isomorphic-fetch";
import qs from "qs";
import { useLoadedEntries } from "@/composables/useLoadedEntries.ts";

const { loadEntries, loadEntriesFromString } = useLoadedEntries();

const props = defineProps({});

const hostname = "localhost";
const port = 5173;
var CLIENT_ID = "85vbmd9vlyyb5kp" //Flogger data
//"irjhf3obwytvv53"; //flogger-ccc4
//"lsu851xgok0qryy"; //Flogger Starscream
//"k2i486lvdpfjyhj"; //"q5qja4ma5qcl0qc"; //flogger-chad: q5qja4ma5qcl0qc //ORIGINAL EXAMPLE: 42zjexze6mfpf7x

const config = {
  fetch,
  clientId: CLIENT_ID,
};

import { Dropbox, DropboxAuth } from "dropbox";
// See https://dropbox.github.io/dropbox-sdk-js/Dropbox.html

const dbxAuth = new DropboxAuth(config);

const dbxAuthReturnUri = `http://${hostname}:${port}/`;

const doAuth = () => {
  console.log("doAuth");
  dbxAuth
    .getAuthenticationUrl(
      dbxAuthReturnUri,
      undefined,
      "code",
      "offline",
      undefined,
      undefined,
      true
    )
    .then((authUrl) => {
      clearDbxSession();
      window.sessionStorage.setItem("codeVerifier", dbxAuth.codeVerifier);
      console.log("dbxAuth.codeVerifier", dbxAuth.codeVerifier);
      window.location.href = authUrl;
    })
    .catch((error) => {
      console.log(
        `Error getting auth URL:`,
        e?.message || e
      );
      clearDbxSession();
    });
};

// Parses the url and gets the access token if it is in the urls hash
const getDbxAuthCodeFromUrl = () => {
  const params = new URL(window.location).searchParams;
  const code = params.get("code");
  // console.log(`getDbxAuthCodeFromUrl: ${code}`);
  return code;
};
const removeAuthCodeFromUrl = (urlString) => {
  let url = new URL(urlString);
  // console.log("url before", url.toString());
  url.searchParams.delete("code");
  // console.log("url after", url.toString());
  return url.toString();
};

const dbxAuthCode = ref(getDbxAuthCodeFromUrl());
const hasRedirectedFromAuth = ref(!!dbxAuthCode.value);

const fileItems = ref([]);
const loadedFile = ref();
const fileContents = ref({});

if (hasRedirectedFromAuth.value) {
  console.log(`dbxAuthReturnUri`, dbxAuthReturnUri);
  console.log(`dbxAuthCode`, dbxAuthCode.value);

  const codeVerifier = window.sessionStorage.getItem("codeVerifier");
  console.log(`codeVerifier:`, codeVerifier);
  dbxAuth.setCodeVerifier(codeVerifier);
  const reloadUrl = removeAuthCodeFromUrl(window.location.href);
  console.log("reloadUrl", reloadUrl);
  console.log("step 1");
  dbxAuth
    // 1. Get token
    .getAccessTokenFromCode(dbxAuthReturnUri, dbxAuthCode.value)
    // 2. Save token and reload
    .then((response) => {
      console.log("step 2");
      window.sessionStorage.setItem(
        "accessToken",
        response.result.access_token
      );
      window.location.href = removeAuthCodeFromUrl(window.location.href);
    })
    .catch((e) => {
      console.log("Error getting access token from URL:", e.error || e);
      window.location.href = removeAuthCodeFromUrl(window.location.href);
    });
  // .catch((error) => {
  //   console.error(error.error || error);
  // });
}

// 3. Get token
let accessToken = window.sessionStorage.getItem("accessToken");
if (accessToken && accessToken != "") {
  console.log("step 3a from sessionStorage");
  dbxAuth.setAccessToken(accessToken);
} else {
  console.log("step 3b check from dbxAuth");
  window.sessionStorage.removeItem("accessToken");
  accessToken = dbxAuth.getAccessToken();
}

console.log("accessToken:", accessToken);

if (accessToken) {
  // 4. Check/refresh token
  console.log("step 4");
  dbxAuth.checkAndRefreshAccessToken();
  // 5. Use token to get files
  console.log("step 5");
  var dbx = new Dropbox({
    auth: dbxAuth,
  });
  dbx
    .filesListFolder({
      path: "",
    })
    // 6. Set fileItems to display
    .then((response) => {
      console.log("step 6");
      fileItems.value = response.result.entries
        .filter((item) => item.path_lower.endsWith(".flogger"))
        .map((item) => {
          console.log("item", item);
          return item;
        });
      // fetchFileContents(fileItems.value);
    })
    .catch((e) => {
      console.log("Error listing dropbox folders:", e?.message || e);
      clearDbxSession();
    });
}

const fetchFileContents = (entries) => {
  dbxAuth.checkAndRefreshAccessToken();
  entries.forEach((item) => {
    dbx
      .filesDownload({ path: item.path_lower })
      .then((response) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          fileContents.value[item.id] = e.target.result;
        };
        reader.readAsText(response.result.fileBlob);
      })
      .catch((error) => {
        console.log(
          `Error downloading file ${item.path_lower} :`,
          e?.message || e
        );
        clearDbxSession();
      });
  });
};

const selectFile = (file) => {
  const { loadEntriesFromString } = useLoadedEntries();
  dbxAuth.checkAndRefreshAccessToken();
  dbx
    .filesDownload({ path: file.path_lower })
    .then((response) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        const fileData = e.target.result;
        // load the file entries content
        loadEntriesFromString(fileData);
        // set the loadedFile
        loadedFile.value = { path: file.path_lower };
      };
      reader.readAsText(response.result.fileBlob);
    })
    .catch((error) => {
      console.log(
        `Error downloading file ${item.path_lower} :`,
        e?.message || e
      );
      clearDbxSession();
    });
};

const unselectFile = () => {
  loadedFile.value = undefined;
  loadEntries([]);
}

const clearDbxSession = () => {
  console.log("clearDbxSession");
  window.sessionStorage.removeItem("accessToken");
  window.sessionStorage.removeItem("codeVerifier");
  dbxAuthCode.value = undefined;
  accessToken = undefined;
  fileItems.value = [];
  fileContents.value = {};
  loadedFile.value = undefined;
  loadEntriesFromString();
};
</script>

<template>
  <!-- Example description and UI -->
  <section class="container main">
    <p>
      To load files from your DropBox account, you need to connect to DropBox
      and authorize Flogger.
    </p>
    <div
      id="pre-auth-section"
      :style="{ display: accessToken ? 'none' : 'block' }"
    >
      <button @click="doAuth">connect to DropBox</button>
    </div>

    <div
      id="authed-section"
      :style="{ display: accessToken ? 'block' : 'none' }"
    >
      <p>You are connected to DropBox.</p>
      <button @click="clearDbxSession">forget DropBox connection</button>
    </div>

    <div
      id="files-section"
      :style="{ display: !loadedFile ? 'block' : 'none' }"
    >
      <p>
        Below are the .flogger files available in your of the App/flogger
        folder.
      </p>
      <ul id="files">
        <li v-for="item in fileItems">
          <a href="#" @click.prevent="() => selectFile(item)">{{
            item.path_display
          }}</a>
        </li>
      </ul>
    </div>

    <div
      id="loadedFile-section"
      :style="{ display: loadedFile ? 'block' : 'none' }"
    >
      <p>
        The loaded file is <b>{{ loadedFile?.path }}</b>
      </p>
      <button @click="unselectFile">close file</button>
    </div>
  </section>
</template>

<style scoped>
#add-entry *:not(.date-validation) {
  display: block;
}

input.error {
  border: 1px solid red;
}

.date-validation.error {
  display: block;
  color: red;
}

#add-entry label {
  margin-top: 20px;
}

ul {
  border-radius: 14px;
  list-style: disc;
  padding: 0.5em;
  margin: 0.5em;
}
</style>

================
File: components/DropBoxFlogs.vue
================
<script setup>
import { useDropboxFlogs } from "@/composables/useDropboxFlogs";
import { useFlogs } from "@/composables/useFlogs";
import AddFlog from "@/components/AddFlog.vue";

const {
  launchConnectFlow,
  hasConnection,
  clearConnection,
  availableFlogs,
  loadFlogEntries,
  addFlog
} = useDropboxFlogs();

const { openFlog } = useFlogs();
// const props = defineProps({});

const selectFile = (file) => {
  loadFlogEntries(file);
  openFlog(file);
};

function handleAddFlog(flogData) {
  console.log("Not implemented yet", flogData.value.filename);
  addFlog({
    url: flogData.value.filename + ".flogger.txt",
    loadedEntries: [],
  });
}
</script>

<template>
  <!-- Example description and UI -->
  <section class="container main">
    <h3>Dropbox Flogs</h3>
    <p>
      To load files from your DropBox account, you need to connect to DropBox
      and authorize Flogger.
    </p>
    <div
      id="pre-auth-section"
      :style="{ display: hasConnection ? 'none' : 'block' }"
    >
      <button @click="launchConnectFlow">connect to DropBox</button>
    </div>

    <div
      id="authed-section"
      :style="{ display: hasConnection ? 'block' : 'none' }"
    >
      <p>You are connected to DropBox.</p>
      <button @click="clearConnection">forget DropBox connection</button>
      <AddFlog @newFlog="handleAddFlog" />
    </div>

    <div id="files-section">
      <!-- :style="{ display: !loadedFile ? 'block' : 'none' }" -->
      <p>
        Below are the .flogger files available in your of the App/flogger
        folder.
      </p>
      <ul id="files">
        <li v-for="item in availableFlogs">
          <a href="#" @click.prevent="() => selectFile(item)">{{
            item.path_display ?? item.url
          }}</a>
        </li>
      </ul>
    </div>
  </section>
</template>

<style scoped>
#add-entry *:not(.date-validation) {
  display: block;
}

input.error {
  border: 1px solid red;
}

.date-validation.error {
  display: block;
  color: red;
}

#add-entry label {
  margin-top: 20px;
}

ul {
  border-radius: 14px;
  list-style: disc;
  padding: 0.5em;
  margin: 0.5em;
}
</style>

================
File: components/Entry.vue
================
<script setup lang="ts">
import { ref, computed } from "vue";
import { IEntry } from '../modules/EntryData'

const props = defineProps<{
  entry: IEntry;
  isEditing: boolean;
  index: number;
}>();


// Emits an event to the parent
const emit = defineEmits([
  'update-entry',
  'stop-editing'
]);

// Utility function to format timestamp to MM/DD/YYYY
function formatDate(timestamp: string | number | Date): string {
  const date = new Date(timestamp);
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  const year = date.getFullYear();
  return `${month}/${day}/${year}`;
}

// Computed property to format the entry date
const formattedDate = computed(() => formatDate(props.entry.date));

// Function to emit the update when blur occurs
function save(entry) {
  emit('update-entry', entry);
  emit('stop-editing', props.index);

  console.log('save() called - emitting event to parent');
  console.log('Updated entry:', entry);
}

</script>




<template>
  <div class="entry">
      <h3>{{ formattedDate }}</h3>

      <div v-if="!isEditing"><pre class="entry__pre">{{ entry.entry }}</pre></div> 
      <!-- Display a textarea if editing -->
      <textarea class='entry__textarea' v-else @blur="save" v-model="entry.entry"></textarea>
    </div>
</template>

<style scoped>
h3 {
  font-weight: 700;
  margin-bottom: 20px;
  font-size: 14px;
}


.entry {
  text-align: left;
  max-width: 600px;
  border-radius: 14px;
  padding: 20px;
  border: 1px solid black;
}

.entry__pre {
  white-space: pre-wrap;
  font-size: 12px;
  font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Consolas, 'DejaVu Sans Mono', monospace;
}

.entry__textarea {
  width: 100%;
  height: auto;
  background-color: cornsilk;
  field-sizing: content;
}

@media (prefers-color-scheme: dark) {
  .entry__textarea {
    background-color: #999;
  }
}



</style>

================
File: components/EntryList.vue
================
<script setup lang="ts">
import { ref } from "vue";
import Entry from "@/components/Entry.vue";
import { IEntry } from '@/modules/EntryData'
import { useFlogs } from "@/composables/useFlogs";

const props = defineProps<{
  entries: Array<IEntry>;
}>();


const emit = defineEmits([
  'copy-entry',
  'delete-entry', 
  'edit-entry',
  'update-entry'
]);

function changeEntry(actionName,entry) {
  emit(`${actionName}-entry`, entry);
}

// Function to catch update from child and emit to grandparent
function updateEntry(updatedEntry: IEntry) {
  console.log('updateEntry() called');
  console.log('Forwarding updated entry to grandparent:', updatedEntry);
  emit('update-entry', updatedEntry);
}

// Track the currently editing entry ID
const editingEntryId = ref(null);

// Function to check if the entry is in editing mode
const isEditingEntry = (index) => {
  return editingEntryId.value === index;
};

const editButtonText = ref('Edit');

// Function to set the editing mode for a specific entry
const setEditing = (index) => {
  editingEntryId.value = index;
  //toggleButton();
};

// Handle stop-editing event from the child component
const stopEditingEntry = (index) => {
  if (editingEntryId.value === index) {
    editingEntryId.value = null;  // Stop editing the entry
  }
};

// not used
// Toggle function that changes the button text and class
const toggleButton = () => {
  if (editButtonText.value === 'Edit') {
    editButtonText.value = 'Save';
    //editButtonClass.value = 'button-clicked';
  } else {
    editButtonText.value = 'Edit';
    //editButtonClass.value = 'button-normal';
  }
};

</script>

<template>
  
  <ul class="entry-list">
    <li v-for="(entry, index) in entries" :key="index">
      <Entry 
        :entry="entry" 
        :isEditing="isEditingEntry(index)" 
        @stop-editing="stopEditingEntry(index)" 
        @update-entry="updateEntry"

        />
      <button class='entry__btn' @click="changeEntry('copy',entry)">Copy</button>
      <button class='entry__btn' @click="setEditing(index)">{{ editButtonText }}</button>
      <button class='entry__btn entry__btn--warn' @click="changeEntry('delete',entry)">Delete</button>
    </li>
  </ul>
</template>

<style scoped>
.entry-list > li {
  border-radius: 14px;
  list-style: none;
  margin-top: 10px;
}

button {
  cursor: pointer;
}

.entry__btn {
  font-size: 10px;
  padding: 2px 4px;
  margin: 3px 5px 0 0;
  color: #999;
  font-weight: bold;
  text-transform: uppercase;
}

.entry__btn:hover {
  color: #000
}

.entry__btn--warn:hover {
  color:red;
}

</style>

================
File: components/LocalFileFlogs.vue
================
<script setup>
import { useFlogs } from "@/composables/useFlogs";
import { useLocalFileFlogs } from "@/composables/useLocalFileFlogs";

const { openFlog } = useFlogs();
// const props = defineProps({});

const { selectedFileFlog, launchOpenFileFlow, launchRequestPermissionsFlow } =
  useLocalFileFlogs();

async function openLocalFileFlog() {
  await launchOpenFileFlow()
  selectedFileFlog.value && openFlog(selectedFileFlog.value)
}
</script>

<template>
  <!-- Example description and UI -->
  <section class="container main">
    <h3>Local File Flogs</h3>
    <button @click="openLocalFileFlog">Open Flog</button>
    <!-- <div>selectedFileFlog = {{ JSON.stringify(selectedFileFlog) }}</div>
    <div>url = {{ selectedFileFlog?.url }}</div>
    <div>permissions = {{ selectedFileFlog?.permissions }}</div>
    <div>loadedEntries = {{ selectedFileFlog?.loadedEntries }}</div> -->
  </section>
</template>

<style scoped>
button {
	border-radius: 10px;
	padding: 6px 10px;
	margin-top: 10px;
	cursor: pointer;
}

</style>

================
File: components/OpenFlogs.vue
================
<script setup>
import { ref } from "vue";
import { useFlogs } from "@/composables/useFlogs";
import EntryData from "@/modules/EntryData.ts";
import AddEntry from "@/components/AddEntry.vue";
import EntryList from "@/components/EntryList.vue";

const { 
  openFlogs, 
  closeFlog, 
  addEntryToFlog, 
  deleteEntryFromFlog,
  editEntryFromFlog,
  saveFlogToSource 
} = useFlogs();
// const props = defineProps({});

function addNewEntry(entryData, flog) {
  const newEntry = new EntryData(
    new Date(entryData.value.date),
    entryData.value.entry
  );
  addEntryToFlog(newEntry, flog);
  saveFlogToSource(flog);
}
const copiedEntry = ref(null); // Initialize reactive copiedEntry
let isEditing = ref(false);

const handleCopyEntry = (entry) => {
  copiedEntry.value = entry;
};


// Handle entry deletion with confirmation
const handleDeleteEntry = (flog, entry) => {
  const confirmDelete = window.confirm('Are you sure you want to delete this entry?');
  
  // If the user confirms deletion, proceed with removing the entry
  if (confirmDelete) {
    deleteEntryFromFlog(flog, entry); // Delete the entry
    console.log('Entry deleted successfully');
  } else {
    console.log('Entry deletion canceled');
  }
};

// Function to handle the update event from the grandchild and update flog
const handleUpdateEntry = (flog, updatedEntry) => {
  console.log('handleUpdateEntry() in grandparent called');
  console.log('Received updated entry:', updatedEntry);

  if (flog) {
    editEntryFromFlog(flog, updatedEntry);
  } else {
    console.error('flog is not defined or initialized');
  }
};

const getTimestamp = () => ref(new Date().toLocaleDateString());
</script>

<template>
  <!-- Example description and UI -->
  <section class="container main">
    <div v-for="flog in openFlogs" :key="flog.id">
      <h4>{{ flog.url }}</h4>
      <button @click.prevent="() => closeFlog(flog)">close flog</button>
      <AddEntry
        @newEntry="(entryData) => addNewEntry(entryData, flog)"
        :copiedEntry="copiedEntry"
        :timestamp="getTimestamp()"
      />
      <EntryList :entries="flog.loadedEntries" 
      :isEditing = "isEditing"
      @edit-entry="editEntryFromFlog" 
      @copy-entry="handleCopyEntry" 
      @delete-entry="(entry) => handleDeleteEntry(flog, entry)" 
      @update-entry="(entry) => handleUpdateEntry(flog, entry)" 
      />
    </div>
  </section>
</template>

<style scoped>
#add-entry *:not(.date-validation) {
  display: block;
}

input.error {
  border: 1px solid red;
}

.date-validation.error {
  display: block;
  color: red;
}

#add-entry label {
  margin-top: 20px;
}

ul {
  border-radius: 14px;
  list-style: disc;
  padding: 0.5em;
  margin: 0.5em;
}
</style>

================
File: composables/useDropboxFiles.ts
================
import { ref, Ref } from "vue"
import * as fetch from "isomorphic-fetch";
import { Dropbox, DropboxAuth } from "dropbox";
// See https://dropbox.github.io/dropbox-sdk-js/Dropbox.html

export interface IDropboxFile {
    path: string;
    content?: string;
    rev?: string;
}

export interface IDropboxFiles {
    launchConnectFlow: () => void
    hasConnection: Ref<boolean>
    clearConnection: () => void
    availableFiles: Ref<IDropboxFile[]>
    loadFileContent: (file: IDropboxFile, callback: (result: { rev: string, content: string }) => any) => void,
    saveFileContent: (file: IDropboxFile, callback: () => any) => void,
    addFile: (file: IDropboxFile, callback: () => any) => void
}

export const useDropboxFiles = (): IDropboxFiles => {


    const hostname = "localhost";
    const port = 5173;
    var CLIENT_ID = "85vbmd9vlyyb5kp" //Flogger data
    //"irjhf3obwytvv53"; //flogger-ccc4
    //"lsu851xgok0qryy"; //Flogger Starscream
    //"k2i486lvdpfjyhj"; //"q5qja4ma5qcl0qc"; //flogger-chad: q5qja4ma5qcl0qc //ORIGINAL EXAMPLE: 42zjexze6mfpf7x

    const config = {
        fetch,
        clientId: CLIENT_ID,
    };

    const dbxAuth = new DropboxAuth(config);

    const dbxAuthReturnUri = `http://${hostname}:${port}/`;

    // Parses the url and gets the access token if it is in the urls hash
    const getDbxAuthCodeFromUrl = () => {
        const params = new URL(window.location.href).searchParams;
        const code = params.get("code");
        // console.log(`getDbxAuthCodeFromUrl: ${code}`);
        return code;
    };
    const removeAuthCodeFromUrl = (urlString) => {
        let url = new URL(urlString);
        // console.log("url before", url.toString());
        url.searchParams.delete("code");
        // console.log("url after", url.toString());
        return url.toString();
    };

    const dbxAuthCode = ref(getDbxAuthCodeFromUrl());
    const hasRedirectedFromAuth = ref(!!dbxAuthCode.value);

    const availableFiles = ref([]);


    const hasConnection = ref(false)


    if (hasRedirectedFromAuth.value) {
        console.log(`dbxAuthReturnUri`, dbxAuthReturnUri);
        console.log(`dbxAuthCode`, dbxAuthCode.value);

        const codeVerifier = window.sessionStorage.getItem("codeVerifier");
        console.log(`codeVerifier:`, codeVerifier);
        dbxAuth.setCodeVerifier(codeVerifier);
        const reloadUrl = removeAuthCodeFromUrl(window.location.href);
        console.log("step 1");
        dbxAuth
            // 1. Get token
            .getAccessTokenFromCode(dbxAuthReturnUri, dbxAuthCode.value)
            // 2. Save token and reload
            .then((response) => {
                console.log("step 2");
                window.sessionStorage.setItem(
                    "accessToken",
                    // @ts-expect-error
                    response.result.access_token
                );
                console.log("reloadUrl", reloadUrl);
                window.location.href = reloadUrl;
            })
            .catch((e) => {
                console.log("Error getting access token from URL:", e.error || e);
                console.log("reloadUrl", reloadUrl);
                window.location.href = reloadUrl;
            });
        // .catch((error) => {
        //   console.error(error.error || error);
        // });
    }

    // 3. Get token
    let accessToken = window.sessionStorage.getItem("accessToken");
    hasConnection.value = (accessToken && accessToken != "") ? true : false
    if (hasConnection.value) {
        console.log("step 3a from sessionStorage");
        dbxAuth.setAccessToken(accessToken);
    } else {
        console.log("step 3b check from dbxAuth");
        window.sessionStorage.removeItem("accessToken");
        accessToken = dbxAuth.getAccessToken();
    }

    console.log("accessToken:", accessToken);

    if (hasConnection.value) {
        // 4. Check/refresh token
        console.log("step 4");
        dbxAuth.checkAndRefreshAccessToken();
        // 5. Use token to get files
        console.log("step 5");
        var dbx = new Dropbox({
            auth: dbxAuth,
        });
        dbx
            .filesListFolder({
                path: "",
            })
            // 6. Set availableFiles to display
            .then((response) => {
                console.log("step 6");
                availableFiles.value = response.result.entries
                    .filter((item) => (item.path_lower.endsWith(".flogger") || item.path_lower.endsWith(".flogger.txt")))
                    .map((item) => {
                        console.log("mapping item", item);
                        const newFile: IDropboxFile = { path: item.path_lower, rev: item[".tag"] }
                        return newFile;
                    });
            })
            .catch((e) => {
                console.log("Error listing dropbox folders:", e?.message || e);
                clearConnection();
            });
    }

    const launchConnectFlow = () => {
        console.log("launchConnectFlow");
        dbxAuth
            .getAuthenticationUrl(
                dbxAuthReturnUri,
                undefined,
                "code",
                "offline",
                undefined,
                undefined,
                true
            )
            .then((authUrl) => {
                clearConnection();
                //@ts-expect-error
                window.sessionStorage.setItem("codeVerifier", dbxAuth.codeVerifier);
                //@ts-expect-error
                console.log("dbxAuth.codeVerifier", dbxAuth.codeVerifier);
                //@ts-expect-error
                window.location.href = authUrl;
            })
            .catch((error) => {
                console.log(`Error getting auth URL:`, error?.message || error);
                clearConnection();
            });

    }

    const clearConnection = () => {
        console.log("clearConnection");
        window.sessionStorage.removeItem("accessToken");
        window.sessionStorage.removeItem("codeVerifier");
        dbxAuthCode.value = undefined;
        accessToken = undefined;
        hasConnection.value = false
        availableFiles.value = [];
    }

    const loadFileContent = async (file: IDropboxFile, callback: (result: { rev: string, content: string }) => any) => {
        console.log('loadFileContent file', file)

        dbxAuth.checkAndRefreshAccessToken();
        await dbx
            .filesDownload({ path: file.path })
            .then((response) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const fileData = e.target.result;
                    callback(
                        {
                            rev: response.result.rev,
                            content: fileData as string
                        }
                    )
                };
                //@ts-expect-error - dbx doesn't have typing for fileBlob for some reason
                reader.readAsText(response.result.fileBlob);
            })
            .catch((error) => {
                console.log(
                    `Error downloading file ${file.path} :`,
                    error?.message || error
                );
                clearConnection();
            });
    }

    const saveFileContent = async (file: IDropboxFile, callback: () => any) => {
        console.log('saveFileContent file', file)

        dbxAuth.checkAndRefreshAccessToken();
        await dbx
            .filesUpload(
                {
                    path: file.path,
                    contents: file.content,
                    mode: { ".tag": "update", "update": file.rev }
                }
            )
            .then((response) => {
                console.log(response)
                callback()
            })
            .catch((error) => {
                console.log(
                    `Error uploading file ${file.path} :`,
                    error.error.error_summary
                );
                // clearConnection();
            });
    }

    const addFile = async (file: IDropboxFile, callback: () => any) => {
        console.log('addFile file', file)

        dbxAuth.checkAndRefreshAccessToken();
        await dbx
            .filesUpload(
                {
                    // Must add the slash in front of paths. This is relative to the root of the app folder in Dropbox
                    path: "/" + file.path,
                    contents: file.content,
                    mode: { ".tag": "add" }
                }
            )
            .then((response) => {
                console.log(response)
                callback()
            })
            .catch((error) => {
                console.log(
                    `Error uploading file ${file.path} :`,
                    error.error.error_summary
                );
                // clearConnection();
            });
    }

    return {
        launchConnectFlow,
        hasConnection,
        clearConnection,
        availableFiles,
        loadFileContent,
        saveFileContent,
        addFile,
    }
}

================
File: composables/useDropboxFlogs.ts
================
import { ref, Ref, watch } from "vue"
import { IFlog, deserializeEntries, serializeEntries } from "@/modules/Flog"
import { useDropboxFiles } from "@/composables/useDropboxFiles"
import { IDropboxFile } from "@/composables/useDropboxFiles";

export interface IDropboxFlog extends IFlog {
    rev: string;
}

export interface IDropboxFlogs {
    // pass through from useDropboxFiles
    launchConnectFlow: () => void;
    // pass through from useDropboxFiles
    hasConnection: Ref<boolean>;
    // pass through from useDropboxFiles
    clearConnection: () => void;
    // map availableFiles from from useDropboxFiles to flogs
    availableFlogs: Ref<IDropboxFlog[]>;
    // makes use of loadFileContent from useDropboxFiles
    loadFlogEntries: (flog: IDropboxFlog) => void;
    // makes use of ... from useDropboxFiles
    saveFlogEntries: (flog: IDropboxFlog) => void;
    addFlog: (flog: IDropboxFlog) => void;
}

const {
    launchConnectFlow,
    hasConnection,
    clearConnection: clearFileConnection,
    availableFiles,
    loadFileContent,
    saveFileContent,
    addFile
} = useDropboxFiles()

const filePathToFlogUrl = (path: string): string => {
    return 'dropbox: ' + path
}

const flogUrlToFilePath = (url: string): string => {
    return url.replace(/^dropbox: /, '')
}

export const useDropboxFlogs = (): IDropboxFlogs => {

    const availableFlogs = ref([]);

    watch(
        availableFiles,
        (availableFiles, oldValue) => {
            const removed = !oldValue ? [] : oldValue
                .filter((file) => availableFiles && !availableFiles.includes(file))
                .map<IDropboxFlog>((file) => ({ url: filePathToFlogUrl(file.path) } as IDropboxFlog))
            const added = !availableFiles ? [] : availableFiles
                .filter((file) => oldValue && !oldValue.includes(file))
                .map<IDropboxFlog>((file) => ({ url: filePathToFlogUrl(file.path) } as IDropboxFlog))
            availableFlogs.value = availableFlogs.value
                .filter((flog) => !removed.includes(flog))
                .concat(added)
        },
        { immediate: true }
    )

    const loadFlogEntries = (flog: IDropboxFlog) => {
        console.log('loadFlogEntries flog', flog)
        loadFileContent(
            { path: flogUrlToFilePath(flog.url) },
            (result) => {
                flog.loadedEntries = deserializeEntries(result.content)
                flog.rev = result.rev;
            }
        )
    }

    const saveFlogEntries = (flog: IDropboxFlog) => {
        console.log('saveFlogEntries flog', flog)
        saveFileContent(
            {
                path: flogUrlToFilePath(flog.url),
                // rev is required, but I'm not 100% sure of usage. 
                // Might be required like this to ensure writing new version of current version. 
                // Or, it might allow specing a new rev to version rather than overwrite.
                rev: flog.rev, 
                content: serializeEntries(flog.loadedEntries)
            } as IDropboxFile,
            () => { } // can parameterize so calling app gets notice once save is complete 
        )
    }

    const addFlog = (flog: IDropboxFlog) => {
        console.log('addFlog flog', flog)
        addFile(
            {
                path: flogUrlToFilePath(flog.url),
                // Is rev needed for mode add?
                // rev: flog.rev, 
                content: serializeEntries(flog.loadedEntries)
            } as IDropboxFile,
            () => { } // can parameterize so calling app gets notice once save is complete 
        )
    }

    const clearConnection = () => {
        clearFileConnection()
        availableFlogs.value = []
    }

    return {
        launchConnectFlow,
        hasConnection,
        clearConnection,
        availableFlogs,
        loadFlogEntries,
        saveFlogEntries,
        addFlog,
    }
}

================
File: composables/useFlogs.ts
================
import { ref } from "vue"
import { IFlog } from "@/modules/Flog"
import { IEntry } from '@/modules/EntryData'
import { useDropboxFlogs, IDropboxFlog } from "@/composables/useDropboxFlogs";
import { useLocalFileFlogs, IFileFlog } from "@/composables/useLocalFileFlogs";

const {
    saveFlogEntries: saveFlogEntries_dropbox,
    addFlog: addFlog_dropbox
} = useDropboxFlogs();

const {
    saveFlogEntries: saveFlogEntries_localFiles,
    addFlog: addFlog_localFiles
} = useLocalFileFlogs(()=>{});

//   const { selectedFileFlog, launchOpenFileFlow, launchRequestPermissionsFlow } = useLocalFileFlogs();

// Using module-scoped state can cause problems with SSR. See 
// https://vuejs.org/guide/scaling-up/state-management#simple-state-management-with-reactivity-api
const openFlogs = ref<IFlog[]>([])

export const useFlogs = () => {

    const openFlog = (
        newFlog: IFlog,
    ) => {
        if (!openFlogs.value.includes(newFlog)) {
            const temp = openFlogs.value
            openFlogs.value.unshift(newFlog)
        }
    }

    const closeFlog = (flog: IFlog) => {
        if (openFlogs.value.includes(flog)) {
            openFlogs.value = openFlogs.value.filter(flogItem => flog != flogItem)
        }
    }

    const addEntryToFlog = (entry: IEntry, flog: IFlog) => {
        flog.loadedEntries.unshift(entry)
    }

    const deleteEntryFromFlog = (flog: IFlog, entry: IEntry) => {
        if (!flog || !Array.isArray(flog.loadedEntries)) {
            console.error('Flog or flog.loadedEntries is undefined or not an array');
            return;
        }
        // Find the index of the entry to delete
        const deleteEntryIndex = flog.loadedEntries.findIndex(flogEntry => flogEntry.id === entry.id);
        if (deleteEntryIndex !== -1) {
            // Remove the entry
            flog.loadedEntries.splice(deleteEntryIndex, 1);
    
            // Save the updated flog to the source to persist the changes
            saveFlogToSource(flog);
        } else {
            console.error('Entry not found in flog.loadedEntries');
        }
    };

    const editEntryFromFlog = (flog: IFlog, entry: IEntry) => {
        if (!flog || !Array.isArray(flog.loadedEntries)) {
            console.error(`Flog or flog.loadedEntries is undefined or not an array: ${flog}`);
            return;
        }
        // Find the index of the entry to delete
        const editEntryIndex = flog.loadedEntries.findIndex(flogEntry => flogEntry.id === entry.id);
        if (editEntryIndex !== -1) {
            // Update the entry at the found index
            flog.loadedEntries[editEntryIndex] = { ...flog.loadedEntries[editEntryIndex], ...entry };
            // Save the updated flog to the source to persist the changes
            saveFlogToSource(flog);
        } else {
            console.error('Entry not found in flog.loadedEntries');
        }
    }

    const saveFlogToSource = (flog: IFlog) => {
        const sourceType = flog.url.split(':')[0];
        switch (sourceType) {
            case 'local file':
                saveFlogEntries_localFiles(flog as IFileFlog)
                break;
            case 'dropbox':
                saveFlogEntries_dropbox(flog as IDropboxFlog)
                break;
            default:
        }
    }

    const addFlogToSource = (flog: IFlog) => {
        const sourceType = flog.url.split(':')[0];
        switch (sourceType) {
            case 'local file':
                addFlog_localFiles(flog as IFileFlog)
                break;
            case 'dropbox':
                addFlog_dropbox(flog as IDropboxFlog)
                break;
            default:
        }
    }

    return {
        openFlogs,
        openFlog,
        closeFlog,
        addEntryToFlog,
        saveFlogToSource,
        deleteEntryFromFlog,
        editEntryFromFlog,
        addFlogToSource
    }
}

================
File: composables/useLoadedEntries.ts
================
import { ref, onMounted, onUnmounted } from 'vue'
import { IEntry } from '../modules/EntryData'

// Global reactivy state, created in module scope, so it's shared by all consumers of this useLoadedEntries composable.
const loadedEntries = ref<IEntry[]>([])

export function useLoadedEntries() {
  // // If we instead defined loadedEntries here, it would be scoped to each consumer of useLoadedEntries
  // const loadedEntries = ref<IEntry[]>([])

  // a composable can update its managed state over time.
  function loadEntries(newEntriesList: IEntry[]): void {
    loadedEntries.value = newEntriesList;
  }
  function loadEntry(newEntry: IEntry): void {
    loadedEntries.value = [...loadedEntries.value, newEntry];
  }
  function loadEntriesFromString(stringEntriesList: string | undefined): void {
    loadedEntries.value = stringEntriesList ? deserializeEntries(stringEntriesList) : [];
  }
  function serializeEntries(entriesList: IEntry[]): string {
    return entriesList.reduce<string>(
      (accumulatedValue, currentEntry, index) => {
        return accumulatedValue + `\n\n${currentEntry.date.toDateString()}\n${currentEntry.entry}`
      }
      , '' //start accumulatedValue with an empty string
    )
  }
  function deserializeEntries(entryData: string): IEntry[] {
    const entriesList: (IEntry | undefined)[] = entryData
      // split text file at date delimiters
      .split(/^\n?\n?([0-1]?[0-9]\/[0-3]?[0-9]\/[0-9]{4})\n|\n\n([0-1]?[0-9]\/[0-3]?[0-9]\/[0-9]{4})\n/)
      // filter out blank array entries (non-date and non-entry)
      .filter(item => item && item != '\n')
      // convert array of [date,entry,date,entry,...] into [{date, entry},{date, entry},...]
      .map<IEntry | undefined>((item, index, arr) => index % 2 == 0 ? { date: new Date(arr[index]), entry: arr[index + 1] } : undefined)
      // filter out undefined remnants
      .filter(item => !!item)
    return entriesList as IEntry[]
  }

  // // a composable can also hook into its owner component's
  // // lifecycle to setup and teardown side effects.
  // onMounted(() => window.addEventListener('mousemove', update))
  // onUnmounted(() => window.removeEventListener('mousemove', update))

  // expose managed state as return value and methods
  return { loadedEntries, loadEntries, loadEntry, loadEntriesFromString, serializeEntries, deserializeEntries }
}

================
File: composables/useLocalFileFlogs.ts
================
import { ref, Ref } from "vue";
import { useLocalStorage } from "@vueuse/core";
import { IEntry } from "@/modules/EntryData";
import { IFlog, deserializeEntries, serializeEntries } from "@/modules/Flog"

export interface IFileFlog extends IFlog {
}

export interface IFileFlogs {
    dataFilePermissions: Ref<string>;
    launchOpenFileFlow: () => void;
    launchRequestPermissionsFlow: () => void;
    selectedFileFlog: Ref<IFileFlog>;
    // dataFileName: Ref<string>;
    // loadFlogEntries: (flog: IFileFlog) => IEntry[]
    dataFileSave: (fileDataObj: any) => void; // Should be fileDataObj: <SOME TYPE FOR FLOGGER FILE DATA>
    dataFileClose: () => void;
    saveFlogEntries: (flog: IFileFlog) => void;
    addFlog: (flog: IFileFlog) => void;
}
// export interface IDropboxFlogs {
//     launchConnectFlow: () => void
//     hasConnection: Ref<boolean>
//     clearConnection: () => void
//     availableFlogs: Ref<IDropboxFlog[]>
//     loadFlogEntries: (flog: IDropboxFlog) => IDropboxFlog[]
// }

// ************************************************************
// This section includes data vars and method functions for
// implementing File System Access API using showOpenFilePicker
// + Indexed DB to store FileHandle across page reloads
// Not supported in many browsers, see
// https://developer.mozilla.org/en-US/docs/Web/API/Window/showOpenFilePicker#browser_compatibility
// But might be the only option to store data in a file on the
// user's system, and not require that they reopen the file on
// every visit and every page load. (However, does require they
// click a button to re-grant permission to the file.)

export const useLocalFileFlogs = (dataLoadedCallback): IFileFlogs => {
    const dataFileHandle = ref({});
    const dataFilePermissions = ref("");
    const dataFileOptions = { mode: "readwrite" };
    // store file name in localStorage so we can use it to
    // retrieve the file handle from indexedDB after page reload
    const dataFileName = useLocalStorage("dataFileName", null);
    const dataFileDataStr = ref("");
    const selectedFileFlog = ref<IFileFlog>()
    // Open a db instance to save file references for later sessions
    let dataFileDB;
    let dataFileDBRequest = indexedDB.open("dataFileDB");
    dataFileDBRequest.onerror = function (e) {
        console.error("Error opening database.", e);
    };
    dataFileDBRequest.onsuccess = function (e) {
        dataFileDB = e.target.result;

        if (dataFileName.value) dataFileReload(dataFileName.value);
    };
    dataFileDBRequest.onupgradeneeded = (event) => {
        dataFileDB = event.target.result;

        dataFileDB.onerror = (event) => {
            console.error("Error loading database.", event);
        };

        // Create an objectStore for this database
        const dataFileObjectStore = dataFileDB.createObjectStore(
            "filerefs"
            // , {
            //   keyPath: "file_id",
            // }
        );

        // Define what data items the objectStore will contain
        // dataFileObjectStore.createIndex("hours", "hours", { unique: false });
        // dataFileObjectStore.createIndex("minutes", "minutes", { unique: false });
        // dataFileObjectStore.createIndex("day", "day", { unique: false });
        // dataFileObjectStore.createIndex("month", "month", { unique: false });
        // dataFileObjectStore.createIndex("year", "year", { unique: false });
        // dataFileObjectStore.createIndex("notified", "notified", { unique: false });

        console.log("Object store created.");
    };

    async function getFileHandleFromPicker() {
        const pickerOpts = {
            types: [
                {
                    description: "Text",
                    accept: {
                        "text/*": [".txt", ".text", ".json"],
                    },
                },
            ],
            excludeAcceptAllOption: true,
            multiple: false,
        };

        // open file picker
        let pickerSelection;
        try {
            pickerSelection = await window.showOpenFilePicker(pickerOpts);
        } catch (error) {
            console.log("Error picking file, probably user canceled:", error);
            return;
        }
        if (!pickerSelection) {
            console.log("no picker selection");
            return;
        }
        // get single file handler from possible array
        const [dataFileHandle] = pickerSelection;
        return dataFileHandle;
    }

    async function launchOpenFileFlow() {
        // get file handle
        dataFileHandle.value = await getFileHandleFromPicker();
        if (!dataFileHandle.value) {
            console.log(`no file handle`);
            return;
        }
        await dataFileCheckPermissions();
        if (dataFilePermissions.value == "prompt") await launchRequestPermissionsFlow()

        if (dataFilePermissions.value == "granted") await dataFileLoad();
        else return
        // await dataFileLoad();

        // store the file handle in indexedDB to open the file later.
        let dataFileDBTransaction = dataFileDB.transaction(
            ["filerefs"],
            "readwrite"
        );
        let dataFileDBObjectStore = dataFileDBTransaction.objectStore("filerefs");
        // console.log(`indexNames`, dataFileDBObjectStore.indexNames);
        // console.log(`keyPath`, dataFileDBObjectStore.keyPath);
        // console.log(`name`, dataFileDBObjectStore.name);
        // console.log(`transaction`, dataFileDBObjectStore.transaction);
        // console.log(`autoIncrement`, dataFileDBObjectStore.autoIncrement);
        let dataFileDBRequest = dataFileDBObjectStore.add(
            dataFileHandle.value,
            dataFileName.value
        );
        dataFileDBRequest.onsuccess = function (e) {
            console.log(e);
        };
    }

    async function dataFileSave(fileDataObj) {
        // Create a FileSystemWritableFileStream to write to.
        const writable = await dataFileHandle.value.createWritable();

        // Write the contents of the file to the stream.
        await writable.write(JSON.stringify(fileDataObj));

        // Close the file and write the contents to disk.
        await writable.close();
    }

    function dataFileClose() {
        dataFileHandle.value = undefined;
        dataFilePermissions.value = "";
        dataFileName.value = "";
        dataFileDataStr.value = "";
    }

    async function dataFileCheckPermissions() {
        dataFilePermissions.value = await dataFileHandle.value.queryPermission(
            dataFileOptions
        );
    }

    async function launchRequestPermissionsFlow() {
        dataFilePermissions.value = await dataFileHandle.value.requestPermission(
            dataFileOptions
        );
        if (dataFilePermissions.value != "granted") {
            console.log(`access request failed`);
            return;
        }
        console.log(`access request granted`);
        await dataFileLoad();
    }

    async function dataFileLoad() {
        try {
            // get file
            let dataFile = await dataFileHandle.value.getFile();
            // get file name
            dataFileName.value = dataFile.name;
            // get file contents
            dataFileDataStr.value = await dataFile.text();
            // parse file contents
            selectedFileFlog.value = {
                url: 'Local file: ' + dataFileName.value,
                permissions: dataFilePermissions.value,
                loadedEntries: deserializeEntries(dataFileDataStr.value),
            }
        } catch (e) {
            console.error(e);
            return;
        }
    }

    async function dataFileReload(file_id) {
        // Retrieve a file you've opened before. Show's no filepicker UI, but can show
        // some other permission prompt if the browser so desires.
        // The browser can choose when to allow or not allow this open.
        let dataFileDBTransaction = dataFileDB.transaction(
            ["filerefs"],
            "readonly"
        );
        let dataFileDBObjectStore = dataFileDBTransaction.objectStore("filerefs");
        // console.log(`indexNames`, dataFileDBObjectStore.indexNames);
        // console.log(`keyPath`, dataFileDBObjectStore.keyPath);
        // console.log(`name`, dataFileDBObjectStore.name);
        // console.log(`transaction`, dataFileDBObjectStore.transaction);
        // console.log(`autoIncrement`, dataFileDBObjectStore.autoIncrement);
        let dataFileDBRequest = await dataFileDBObjectStore.get(file_id);
        dataFileDBRequest.onsuccess = async function (e) {
            dataFileHandle.value = dataFileDBRequest.result;

            if (!dataFileHandle.value) {
                console.log(`no result`);
                return;
            }

            // Permissions for the handle may have expired while the handle was stored
            // in IndexedDB. Before it is safe to use the handle we should request at
            // least read access to the handle again.
            await dataFileCheckPermissions();

            // // Rejects if file is no longer readable, either because it doesn't exist
            // // anymore or because the website no longer has permission to read it.
            // let file = await dataFileHandle.value.file();
            // // ... read from file

            // // Rejects if file is no longer writable, because the website no longer has
            // // permission to write to it.
            // let file_writer = await dataFileHandle.value.createWritable();
            // // ... write to file_writer

            if (dataFilePermissions.value == "granted") await dataFileLoad();
        };
    }

    async function saveFlogEntries(flog: IFileFlog) {
        // Create a FileSystemWritableFileStream to write to.
        // @ts-expect-error -- dataFileHandle ref isn't typed well yet
        const writable = await dataFileHandle.value.createWritable();

        // Write the contents of the file to the stream.
        await writable.write(serializeEntries(flog.loadedEntries));

        // Close the file and write the contents to disk.
        await writable.close();
    }

    async function addFlog(flog: IFileFlog) {
        // Create a FileSystemWritableFileStream to write to.
        // @ts-expect-error -- dataFileHandle ref isn't typed well yet
        const writable = await dataFileHandle.value.createWritable();

        // Write the contents of the file to the stream.
        await writable.write(serializeEntries(flog.loadedEntries));

        // Close the file and write the contents to disk.
        await writable.close();
    }

    return {
        // dataFileName,
        selectedFileFlog,
        dataFilePermissions,
        launchOpenFileFlow,
        launchRequestPermissionsFlow,
        dataFileSave,
        dataFileClose,
        saveFlogEntries,
        addFlog
    };
};

================
File: modules/EntryData.ts
================
export interface IEntry extends EntryData {}

export default class EntryData {
  date: Date;
  entry: string;

  constructor(date: Date, entry: string) {
    this.date = date;
    this.entry = entry;
  }
}

================
File: modules/Flog.ts
================
import { IEntry } from './EntryData'

export interface IFlog {
    url: string,
    permissions?: string,
    loadedEntries: IEntry[],
}

export function serializeEntries(entriesList: IEntry[]): string {
    console.log('entriesList', entriesList)
    return entriesList.reduce<string>(
        (accumulatedValue, currentEntry, index) => {
            console.log(currentEntry)
            const entryString = `${currentEntry.date.toLocaleDateString()}`
                + "\n"
                + `${currentEntry.entry}`
            console.log(currentEntry, entryString)
            return accumulatedValue + ((index > 0) ? '\n\n' : '') + entryString
        }
        , '' //start accumulatedValue with an empty string
    )
}

// Expects entryData string in this format:
// 8/22/2024
// Entry text
// 
// 8/22/2024
// Entry text
// 
export function deserializeEntries(entryData: string): IEntry[] {
    const entriesList: (IEntry | undefined)[] = entryData
        // split text file at date delimiters
        .split(/^\n?\n?([0-1]?[0-9]\/[0-3]?[0-9]\/[0-9]{4})\n|\n\n([0-1]?[0-9]\/[0-3]?[0-9]\/[0-9]{4})\n/)
        // filter out blank array entries (non-date and non-entry)
        .filter(item => item && item != '\n')
        // convert array of [date,entry,date,entry,...] into [{date, entry},{date, entry},...]
        .map<IEntry | undefined>((item, index, arr) => index % 2 == 0 ? { date: new Date(arr[index]), entry: arr[index + 1] } : undefined)
        // filter out undefined remnants
        .filter(item => !!item)
    return entriesList as IEntry[]
}

export interface IFlogNewParams extends IFlog { }

================
File: App.vue
================
<template>
  <div>
    <h1>FLogger!</h1>
  </div>
  <div v-if="openFlogs.length == 0">
      <AddEntry @newEntry="addNewEntry" :timestamp="timestamp" />
    <Suspense>
      <DropBoxFlogs />
    </Suspense>
    <br />
    <hr />
    <!-- <LocalFileFlogs /> -->
    <br />
    <hr />
  </div>
  <OpenFlogs />
  <br />
  <hr />
  <EntryList :entries="loadedEntries" />
</template>

<script setup>
import { ref } from "vue";
import EntryList from "@/components/EntryList.vue";
import AddEntry from "@/components/AddEntry.vue";
import DropBoxFlogs from "@/components/DropBoxFlogs.vue";
import OpenFlogs from "@/components/OpenFlogs.vue";
// import LocalFileFlogs from "@/components/LocalFileFlogs.vue";
import { useFlogs } from "@/composables/useFlogs";
import { useLoadedEntries } from "@/composables/useLoadedEntries.ts";

const { openFlogs } = useFlogs();
const { loadedEntries, loadEntries, loadEntry } = useLoadedEntries();

const timestamp = ref(new Date().toLocaleDateString());

function addNewEntry(entryData) {
  console.log('Not implemented yet')
}

</script>

<style scoped>
h2 {
  font-size: 2em;
}

* {
  font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Consolas, 'DejaVu Sans Mono', monospace;
}
</style>

================
File: main.js
================
import { createApp } from 'vue'
import './style.css'
import App from './App.vue'

const app = createApp(App)

app.mount('#app')

================
File: style.css
================
:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-text-size-adjust: 100%;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1, h2, h3, h4 {
  line-height: 1.1;
  padding: 1em 0;
}
h1 {
  font-size: 3.5em;
}
h2 {
  font-size: 2.8em;
}
h3 {
  font-size: 2.1em;
}
h4 {
  font-size: 1.4em;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

.card {
  padding: 2em;
}

#app {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}
